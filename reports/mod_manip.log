Traceback (most recent call last):
  File "/home/ubuntu/miniconda3/envs/prepa/lib/python3.9/site-packages/jupyter_cache/executors/utils.py", line 51, in single_nb_execution
    executenb(
  File "/home/ubuntu/miniconda3/envs/prepa/lib/python3.9/site-packages/nbclient/client.py", line 1112, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/home/ubuntu/miniconda3/envs/prepa/lib/python3.9/site-packages/nbclient/util.py", line 74, in wrapped
    return just_run(coro(*args, **kwargs))
  File "/home/ubuntu/miniconda3/envs/prepa/lib/python3.9/site-packages/nbclient/util.py", line 53, in just_run
    return loop.run_until_complete(coro)
  File "/home/ubuntu/miniconda3/envs/prepa/lib/python3.9/asyncio/base_events.py", line 642, in run_until_complete
    return future.result()
  File "/home/ubuntu/miniconda3/envs/prepa/lib/python3.9/site-packages/nbclient/client.py", line 553, in async_execute
    await self.async_execute_cell(
  File "/home/ubuntu/miniconda3/envs/prepa/lib/python3.9/site-packages/nbclient/client.py", line 857, in async_execute_cell
    self._check_raise_for_error(cell, exec_reply)
  File "/home/ubuntu/miniconda3/envs/prepa/lib/python3.9/site-packages/nbclient/client.py", line 760, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
"""Importation les biblioth√®ques scientifiques n√©cessaires :  numpy, matplotlib.pyplot, numpy.random"""
import numpy as np
import matplotlib.pyplot as plt
import numpy.random as rd


"""Simulation des valeurs. On a 5 jeux de mesures, on va donc utiliser un tableau numpy. Vous devez :
- Cr√©er trois vecteurs numpy contenant les 5 r√©sultats de mesurage des tensions d'entr√©e et de sortie
- Cr√©er trois vecteurs numpy contenant les 5 incertitudes associ√©es aux tensions d'entr√©e et de sortie
(il faudra peut-√™tre plus de trois vecteurs s'il y a plusieurs sources d'incertitudes)
- Utiliser les vecteurs pr√©c√©dents pour cr√©er 3 tableaux contenant N √©chantillons des tensions d'entr√©e et
de sortie associ√©es aux distributionx choisies pour d√©crire la dispersion des r√©sultats de mesurage.
Rappel de syntaxe : rd.normal(x_mes, ux_mes, (N, k)) ou rd.uniform(x_mes, ux_mes, (N, k))
o√π x_mes et ux_mes sont les vecteurs associ√©es aux r√©sultats de mesurage et incertitudes
et k la taille des deux vecteurs.
"""
v1_m = np.array([0])
v2_m = np.array([0])
vs_m = np.array([0])
v1_u = np.array([0])
v2_u = np.array([0])
vs_u = np.array([0])

k = len(v1_m)
N = 1000000 # Nombre de simulations

v1_sim = v1_m + rd.uniform(-v1_u, v1_u, (N, k))  # Il faudra peut-√™tre plusieurs tableaux si vous avez plusieurs sources d'incertitude
v2_sim = v2_m + rd.uniform(-v2_u, v2_u, (N, k))  # Il faudra peut-√™tre plusieurs tableaux si vous avez plusieurs sources d'incertitude
vs_sim = vs_m + rd.uniform(-vs_u, vs_u, (N, k))  # Il faudra peut-√™tre plusieurs tableaux si vous avez plusieurs sources d'incertitude


"""
Obtenir le tableau des valeurs simul√©es  de alpha
"""
alpha_sim = np.array([])  # LIGNE A MODIFIER


"""
D√©terminer la moyenne et l'√©cart-type pour chaque jeux de mesure sur les N √©chantillons.
On rappelle :
mean(tableau, axis = 0) pour moyenner par colonne
std(tableau, ddof=1,  axis = 0) pour calculer l'√©cart-type par colonne
"""
alpha_sim_m = np.mean(alpha_sim, axis=0)  # Moyenne des N simulations pour chaque mesure
alpha_sim_u = std(alpha_sim, ddof=1,  axis = 0)  # Ecart-type des N simulations pour chaque mesure

"""
Calculer la moyenne des valeurs de alpha et son incertitude.
On rappelle que l'incertitude sur la moyenne s'√©crit : Ecartype des 5 valeurs / sqrt(5)
"""
alpha_m = np.mean(alpha_sim_m)
alpha_u = np.std(alpha_sim_m) / np.sqrt(k)


"""Calculer les √©carts normalis√©es pour chaque jeu de mesure"""
alpha_en = 0  # LIGNE A MODIFIER

"""
Analyse des diff√©rents r√©sultats. On donne ici le trac√© √† analyser.
"""
f, ax = plt.subplots()  # On va tracer les barres d'incertitude et la comparer la valeur moyenne.
f.suptitle("")  # Titrer le graphique
ax.set_ylabel("")  # Titrer les ordonn√©es

ax.errorbar(np.arange(k), alpha_sim_m, yerr=alpha_sim_u, capsize=2)  # Repr√©sentation des valeurs
ax.plot([-1, k], [alpha_m, alpha_m], color='b')  # Valeur mesur√©e de alpha


f1, ax1 = plt.subplots()  # On va tracer les √©carts normalis√©s
f1.suptitle("")  # Titrer le graphique

ax1.plot(np.arange(k), alpha_en, marker='+')  # Ecarts normalis√©s

plt.show() 

------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mNameError[0m                                 Traceback (most recent call last)
[0;32m<ipython-input-1-23231f79ec99>[0m in [0;36m<module>[0;34m[0m
[1;32m     43[0m """
[1;32m     44[0m [0malpha_sim_m[0m [0;34m=[0m [0mnp[0m[0;34m.[0m[0mmean[0m[0;34m([0m[0malpha_sim[0m[0;34m,[0m [0maxis[0m[0;34m=[0m[0;36m0[0m[0;34m)[0m  [0;31m# Moyenne des N simulations pour chaque mesure[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 45[0;31m [0malpha_sim_u[0m [0;34m=[0m [0mstd[0m[0;34m([0m[0malpha_sim[0m[0;34m,[0m [0mddof[0m[0;34m=[0m[0;36m1[0m[0;34m,[0m  [0maxis[0m [0;34m=[0m [0;36m0[0m[0;34m)[0m  [0;31m# Ecart-type des N simulations pour chaque mesure[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m     46[0m [0;34m[0m[0m
[1;32m     47[0m """

[0;31mNameError[0m: name 'std' is not defined
NameError: name 'std' is not defined

